+++
date = '2019-04-21'
title = 'ocaml ppx'
tags = ['ocaml']
+++

rust con ä¸Šæœ‰ä¸¤ä¸ªä¸»é¢˜éƒ½æ¶‰åŠäº† rust çš„ procedural macroã€‚
æƒ³èµ·äº† ocaml çš„ ppxï¼Œæƒ³åˆ°äº†ï¼Œé‚£å°±å†™ä¸€å†™ã€‚

---

[deriving](https://github.com/ocaml-ppx/ppx_deriving) æ˜¯æ¯”è¾ƒå¸¸ç”¨çš„ä¸€ä¸ª ppx åº“ã€‚
æ¯”å¦‚ä¸‹é¢è¿™ä¸ªä¾‹å­ï¼Œä¼š rust çš„çœ‹ç€åƒ rustï¼Œä¼š haskell çš„çœ‹ç€åƒ haskellã€‚
ï¼ˆå¤§æ¦‚ï¼Œæ²¡æœ‰äººæ˜¯å…ˆä¼š ocaml çš„ ğŸ˜‚

```ocaml
type point3d = float * float * float
[@@deriving show]
```

é‚£ä¹ˆï¼Œè¿™ä¸ª `@@deriving` æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿ
å®˜æ–¹æ–‡æ¡£é‡Œåªæœ‰å¯¥å¯¥æ•°è¯­ï¼Œ[Attributes](https://caml.inria.fr/pub/docs/manual-ocaml-4.07/extn.html#sec260)ã€[Extensions](https://caml.inria.fr/pub/docs/manual-ocaml-4.07/extn.html#sec262)ï¼Œè¿™ä¸ªæ–‡æ¡£ï¼Œå¤§æ¦‚æ²¡äººèƒ½çœ‹æ˜ç™½â€¦â€¦
è¿™ç§æ—¶å€™ï¼Œå°±åªèƒ½é ç¤¾åŒºå†™çš„å·¥å…·å’Œæ•™ç¨‹äº†â€¦â€¦

å…¶å® ppx/macro ä¹Ÿè¿˜æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ ast è¾“å‡º astï¼Œå†™ä¹‹å‰å…ˆæƒ³æ˜ç™½è¦åšä»€ä¹ˆå°±å¯ä»¥äº†ã€‚
è°ƒè¯•çš„è¯ï¼Œæœ€ç²—æš´çš„å°±æ˜¯æ‰“å°çœ‹ä¸‹æ˜¯å¦ç¬¦åˆé¢„æœŸï¼Œä¸è¿‡å¥½åƒä¹Ÿæ²¡æœ‰ä¸ç²—æš´çš„æ–¹æ³•ï¼Ÿ
æ¯”å¦‚å‰é¢çš„ä¾‹å­ï¼Œè¾“å‡ºçš„ä»£ç æ˜¯è¿™æ ·çš„

```ocaml
(* ocamlfind ocamlc -dsource -linkpkg -package ppx_deriving.std point3d.ml *)
type point3d = float * float * float [@@deriving show]

let rec (pp_point3d : Format.formatter -> point3d -> Ppx_deriving_runtime.unit)
    =
    (let open! Ppx_deriving_runtime in
     fun fmt (a0, a1, a2) ->
         Format.fprintf fmt "(@[";
         (Format.fprintf fmt "%F") a0;
         Format.fprintf fmt ",@ ";
         (Format.fprintf fmt "%F") a1;
         Format.fprintf fmt ",@ ";
         (Format.fprintf fmt "%F") a2;
         Format.fprintf fmt "@])") [@ocaml.warning "-A"]


and show_point3d : point3d -> Ppx_deriving_runtime.string =
    fun x -> Format.asprintf "%a" pp_point3d x
```

---

å­¦ ppx å…¥é—¨ä¾‹å­æ˜¯ `ppx_getenv`ï¼Œä» [ç¡¬æ€¼ AST](https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/) åˆ° [ç¤¾åŒºæ²‰æ·€äº†ä¸€äº›å·¥å…·](http://rgrinberg.com/posts/extension-points-3-years-later/) ï¼Œå†åˆ°å·¥å…·æ•´åˆæˆ [ppxlib](https://github.com/ocaml-ppx/ppxlib/blob/master/HISTORY.md)ã€‚
ppxlib ç¡®å®å°†åŒ¹é…è¿‡ç¨‹ç®€åŒ–äº†å¾ˆå¤šï¼Œä½†æ˜¯ ast_mapper å¯ä»¥ç…§ç€ `ocamlc -dparsetree` å†™ï¼Œppxlib çš„ API åˆ™è®©äººæ‡µé€¼â€¦â€¦

`ppx_getenv` ä¼šå°† `let user = [%getenv "USER"]` æ”¹å†™æˆ `let user = Some("h11")`ï¼Œåœ¨ç¼–è¯‘æ—¶è®¡ç®—äº† `Sys.getenv_opt "USER"`ã€‚
å¯ä»¥é€šè¿‡ `ocamlc -dparsetree get-user-example.ml` å¾—åˆ°è¦å¤„ç†çš„è¯­æ³•æ ‘ï¼Œç„¶åç…§ç€ [Parsetree](https://caml.inria.fr/pub/docs/manual-ocaml-4.07/libref/Parsetree.html) æŠŠè¾“å…¥çš„è¯­æ³•æ ‘å†™ä¸‹æ¥ã€‚
æ¯”å¦‚ `[%getenv ...]` æ˜¯ `Pexp_extension`ï¼Œå‚æ•°æ˜¯ `Pexp_constant PConst_string`ã€‚

```ocaml
open Asttypes
open Parsetree

let build_exp loc env =
    match Sys.getenv_opt env with
        | None ->
            let lid = { txt= Longident.parse "None"; loc } in
            Ast_helper.Exp.construct lid None
        | Some e ->
            let exp = Ast_helper.Exp.constant (Pconst_string (e, None)) in
            let lid = { txt= Longident.parse "Some"; loc } in
            Ast_helper.Exp.construct lid (Some exp)


let getenv_translate loc = function
    (* match `"USER"`  *)
    | PStr
            [ { pstr_desc=
                    Pstr_eval
                        ({ pexp_desc= Pexp_constant (Pconst_string (env, None)); _ }, _)
              ; _
              }
            ] ->
        build_exp loc env
    | _ ->
        raise
            (Location.Error
                 (Location.error
                      ~loc
                      "[%getenv] accepts a string, e.g. [%getenv \"USER\"]"))


let ppx_mapper _argv =
    let open Ast_mapper in
    let expr_mapper mapper = function
        (* match `[%getenv ...]`  *)
        | { pexp_desc= Pexp_extension ({ txt= "getenv"; loc }, payload); _ } ->
            getenv_translate loc payload
        | other -> default_mapper.expr mapper other
    in
    { default_mapper with expr= expr_mapper }


let () = Ast_mapper.register "getenv" ppx_mapper
```

ä¹‹åæŠŠ ppx ç¼–è¯‘å¥½å°±èƒ½ä½¿ç”¨äº†

```
$ ocamlfind ocamlc -linkpkg -package compiler-libs.common getenv.ml -o ppx_getenv
$ ocamlc get-user-example.ml -ppx './getenv.ppx' -dsource
```

æ•´ä¸ªè¿‡ç¨‹ç”± `Ast_mapper` é©±åŠ¨ï¼ŒåŒ¹é… `Parsetree`ï¼Œå†é€šè¿‡ `Ast_helper` æ„é€ è¿”å›å€¼ã€‚å…¨ç¨‹æ‰‹åŠ¨æ„é€  ASTï¼Œç¡®å®ä¸çˆ½ã€‚
å¦‚æœåªæ˜¯å†™ extensionï¼Œé‚£ä¹ˆç›´æ¥ ppxlib ä¹ŸæŒºå¥½ã€‚ä½†æ˜¯æ€ä¹ˆç”¨ ppxlib å†™ attributeï¼Œæˆ‘æ˜¯æ²¡çœ‹æ˜ç™½â€¦â€¦

---

å›åˆ°æœ€åˆçš„ä¾‹å­ï¼Œ`deriving_eq` è¦æ€ä¹ˆå®ç°å‘¢ï¼Ÿ
é¦–å…ˆï¼Œè¾“å…¥æ˜¯ç±»å‹ç”³æ˜ï¼Œè¾“å‡ºæ˜¯ `eq_type-name` å‡½æ•°ã€‚
ï¼ˆå¥½äº†å¥½äº†ï¼Œad hoc polymorphism æ²¡æœ‰å°±æ²¡æœ‰äº†ï¼Œä¸è¦å–·äº†ã€‚

å…¶æ¬¡ï¼Œ`deriving_eq` æ˜¯æ”¾åœ¨ç±»å‹ç”³æ˜åé¢ï¼Œæ‰€ä»¥è¦å®ç°çš„æ˜¯ `item-attribute`ã€‚
ä¸çŸ¥é“ä»€ä¹ˆæ˜¯ `item-attribute`ï¼Ÿå®˜æ–¹æ–‡æ¡£ã€‚
ç®€å•è®²ï¼Œ`extension` æ˜¯è¯­æ³•ä¸Šçš„å ä½ç¬¦ï¼Œæ¯”å¦‚å‰é¢ç”¨ `[%getenv "USER"]` ä»£æ›¿ `Some(user)`ï¼Œå°±æ˜¯ `extension` ä»£æ›¿äº† [`expr`](https://caml.inria.fr/pub/docs/manual-ocaml-4.07/expr.html#expr)ã€‚
è€Œ `attribute` ç±»ä¼¼æ³¨è§£ï¼Œä¿®é¥°åŸæœ¬å®Œæ•´çš„è¯­å¥ã€‚`type point3d = float * float * float` æœ¬èº«æ˜¯å®Œæ•´çš„ï¼Œè¦åšçš„åªæ˜¯åŠ ä¸Šæ ‡è¯†ï¼Œæ–¹ä¾¿ä¹‹ååšå±•å¼€ã€‚
è¿™ç‚¹çœ‹ `Parsetree` å¯èƒ½æ›´å¥½ç†è§£ï¼Œæ¯”å¦‚ `type expression = { expression_desc; attributes }`ã€‚è¿™é‡Œ expression_desc å¯ä»¥æ˜¯ä¸€ä¸ª extensionï¼Œè€Œ attributes åˆ™å¯ä»¥æ˜¯ç©ºæ•°ç»„ã€‚

å‡è®¾è¾“å…¥æ˜¯ `type point3d = float * float * float [@@deriving_eq]`ï¼Œä¸€æ ·å…ˆè§‚å¯Ÿ `ocamlc -dparsetree point3d.ml` çš„è¾“å‡ºã€‚
æˆ‘ä»¬è¦å¤„ç†çš„æ˜¯å¸¦ `attribute "deriving_eq"` çš„ `type_declaration`ï¼Œä¹‹åæ ¹æ® `type_declaration` é‡Œå…·ä½“çš„å±æ€§å®ç° `eq_type_name`ï¼Œæ’å…¥åˆ°æºä»£ç é‡Œã€‚
æƒ³ä¸€æƒ³è¦æ‰‹å†™ eq å‡½æ•°çš„ AST å°±è§‰å¾—å¯æ€•ï¼Œtype_declaration çš„ deriving è¿˜æ˜¯å»å†™ ppx_deriving plugin å§â€¦â€¦

å—¯ï¼Œå‘äº†â€¦â€¦
